/* Bo Sullivan
* CSCI 241 Spring 2020
* Dr. Scott Wehrwein
* Lab 8, May 30, 2020
* 
* Components.java is purposed to read in input .txt file from the command line and then
* It will make use of 3 helper methods and a DFS search to count the connected components from
* the .txt file. Makes use of scanner class, file, and fileNotFoundException imports.
*
* This Java source file was generated by the Gradle 'init' task.
*/
package lab8;

import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;

public class Components {
   //boolean matrix visited
   boolean[] visited;
   // adjacency matrix 2D
   int adjMatrix[][];
   
   /* method to initialize and populate the boolean and 2D array.
   * Makes use of Scanner and a method similar to main in taking a String and args.
   * Try catch exception needed for possible fileNotFound Exception.
   * helper printing methods commented out for debugging
   * 
   * Will populate boolean array to default false values for as many
   * nodes are taken from the first int in the .txt file
   *
   * Will place a 1 where the 2D matrix has a connection/edge
   */
   private void matricesCreator(String args) {
      try {
         File f = new File(args);
         Scanner sc = new Scanner(f);
         int maxNodes = sc.nextInt();
         adjMatrix = new int[maxNodes][maxNodes];
         visited = new boolean[maxNodes];
         while (sc.hasNext()) {
            adjMatrix[sc.nextInt()][sc.nextInt()] = 1;
         }
        // for (int i = 0; i < adjMatrix.length; i++) {
        //    System.out.println(Arrays.toString(adjMatrix[i]));
        // }
        // for (int i = 0; i < visited.length; i++) {
        //    System.out.println(visited[i]);
         //}
        // //closing scanner
         sc.close();
      }
      catch (FileNotFoundException exc) {
         System.out.println("Could not find file " + System.in);
      }
   }
   
   /* DFSVisit method takes a boolean matrix and an int n
   *
   * For loop to iterate the boolean matrix and check the boolean values
   * Then it changes the boolean value at i to true, and recursively calls itself
   * on i if there is an edge at that position indicated by the 1 we placed in
   * into the 2D array from createMatrices().
   */
   private void DFSVisit(boolean[] visited, int n) {
      visited[n] = true;
      
      for (int i = 0; i < visited.length-1; i++) {
         if (visited[i] == false && adjMatrix[n][i] == 1) {
            visited[i] = true;
            DFSVisit(visited, i); 
         }
      }
   }
   
   /* ComponentCounter, takes a boolean array visited with an int n.
   * 
   * Exact same method with exception to the if check for an edge == 1.
   * Makes use a component counter every time we have to call DFSVisit() it
   * will increment to count connected components.
   */
   private int componentCounter(boolean[] visited, int n) {
      int components = 0;
      visited[n] = true;
      for (int i = 0; i < visited.length-1; i++) {
      
         if (visited[i] == false) {
            visited[i] = true;
            components++;
            DFSVisit(visited, i);
         }
      }
      return components;
   }
   
   /*
   * getCCCount() is a helper method to call in main to print out the return
   * of componentCounter.
   * Arbitrarily starts with position 0.
   */
   private void getCCCount() {
   
      System.out.println(componentCounter(visited, 0));
   }
   
   /* Main method will create an object of the Components class.
   * Will call matricesCreator(0) on args[0].
   * And lasty will print the component counter return result.
   */
   public static void main(String[] args) {

      Components c = new Components();
      c.matricesCreator(args[0]);
      c.getCCCount();
   }
}
